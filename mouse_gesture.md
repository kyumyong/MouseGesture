# Mouse Gesture Program

사용자가 마우스 오른쪽 버튼을 누르고 있는 동안의 마우스 동작을 인식하여, 해당 동작에 매핑된 기능을 실행하는 프로그램입니다.

## To do
-마우스 오른쪽 버튼을 누를 때, 이전에 생겼던 선그리기 잔상이 잠시동안 보이는 문제->gemini에게 3번 해결책을 제시했으나 해결못함. Chatgpt가 한 번에 해결
-윈도우 폴더에서는 창 닫기 기능이 동작하지 않음 -> '작업 관리자' 제외한 다른 앱에서는 동작하는 것을 확인
-마우스 제스처 기능이 활성화된 경우 각 창의 오른쪽 클릭하면 나오는 메뉴 비활성화 & 사각형 영역 표시 비활성화->gemini 해결못함. 해결하려면 윈도우 레지스트리 건드려야 하는 듯->다시 생각해보니, OS에 마우스 이벤트를 전달을 막으면 안 되고 OS가 앱에 주는 명령을 막아야 할 듯
    :listener_thread.suppress_event() 또는 win32_event_filter 이용
    https://pynput.readthedocs.io/en/latest/faq.html
    https://learn.microsoft.com/en-gb/windows/win32/api/winuser/ns-winuser-msllhookstruct
    :ChatGPT 답변 -> 종합하면 pyWinhook으로 구현하는 게 좋을 듯. 그런데 pyWinhook은 오래되고 관리되지 않고 있는 문제 있음
        pyWinhook만 Windows 저수준(mouse LL hook) 에서 이벤트 suppress(return False) 를 공식적으로 지원한다.
        pynput 은 suppress 지원 O (단, Windows에서는 "Full suppress"가 100% 보장되지는 않음)
        pywin32 단독으로는 suppress 기능 X, 대신 RawInput / SetWindowsHookEx(Win32 API 직접 호출) 방식으로 저수준 hook + suppress 구현 가능
    :마우스 우클릭은 하드웨어 $\rightarrow$ 드라이버 $\rightarrow$ OS $\rightarrow$ 애플리케이션의 단계를 거쳐 전달
        -윈도우 API함수인 TrackPopupMenu의 호출이 바로 **"메뉴를 띄우라"**는 최종적인 OS 명령이 됩니다. 탐색기가 셸 확장을 통해 조합한 메뉴 구조를 OS에 전달하며, 해당 위치에 메뉴를 표시하라고 명령합니다
        -가장 효과적인 방법은 윈도우 OS 레벨에서 **우클릭 이벤트($WM\_RBUTTONDOWN$)**가 해당 애플리케이션의 메시지 큐에 도달하는 것을 원천적으로 차단(억제)하는 것
        -WM_RBUTTONUP 또는 WM_CONTEXTMENU 차단
    :pywinhook을 사용하려면 visual studio c++ 설치해야 하는데, 지금 C 남은 용량보다 큼
    :수많은 디버깅 시간을 투자하여 원인을 알아냄. SetWindowsHookExW 함수에 **"우리는 64비트 주소를 쓸 거야"**라고 명확히 알려주어 주소 잘림 현상을 방지(gemini의 block_right_click_final.py 참고)
-마우스 우클릭 후 드래그를 너무 오래 하면 좌표 저장을 많이 하므로, 좌표 저장 상한선 만들기
-윈도우->리눅스로 소스코드 보내면 에러나는 이유(우선수위 낮음)
-리팩토링

## 기능

이 파이썬 파일(`mouse_gesture.py`)은 **마우스 제스처(Mouse Gesture)** 기능을 구현한 프로그램입니다.

사용자가 **마우스 오른쪽 버튼을 누른 상태로 마우스를 움직이면(드래그)**, 그 움직임의 방향을 인식하여 미리 지정된 윈도우 명령이나 단축키를 실행해 주는 도구입니다.

주요 동작 방식과 기능은 다음과 같습니다.

### 1. 사용자 경험 (작동 방식)
* **시각 효과:** 마우스 오른쪽 버튼을 누르고 움직이면 화면에 **녹색 선**이 그려져 현재 어떤 제스처를 그리고 있는지 시각적으로 보여줍니다.
* **실행 시점:** 마우스 오른쪽 버튼을 **뗄 때** 제스처를 분석하고 명령을 수행합니다.

### 2. 제스처별 기능 (매핑)
코드의 `analyze_gesture` 함수에 정의된 움직임과 기능은 다음과 같습니다.

| 제스처 방향 | 움직임 설명 | 실행 기능 | 구현 방식 |
| :--- | :--- | :--- | :--- |
| **→ (우)** | 왼쪽에서 오른쪽으로 | **다음 페이지** | `Alt` + `Right` (브라우저 등에서 앞으로 가기) |
| **← (좌)** | 오른쪽에서 왼쪽으로 | **이전 페이지** | `Alt` + `Left` (브라우저 등에서 뒤로 가기) |
| **↑ (상)** | 아래에서 위로 | **복사 (Copy)** | `Ctrl` + `C` |
| **↓ (하)** | 위에서 아래로 | **붙여넣기 (Paste)** | `Ctrl` + `V` |
| **↙ (좌하향)** | 오른쪽 위 → 왼쪽 아래 대각선 | **창 최소화** | 현재 활성창 내리기 |
| **↗ (우상향)** | 왼쪽 아래 → 오른쪽 위 대각선 | **창 최대화/복구** | 현재 활성창 꽉 채우기 or 원래 크기로 |
| **↖ (좌상향)** | 오른쪽 아래 → 왼쪽 위 대각선 | **창 닫기** | 현재 활성창 종료 (`Alt`+`F4` 포함) |

### 3. 기술적 구현 특징

이 코드는 다음과 같은 라이브러리와 기술을 사용하여 구현되었습니다.

* **마우스 입력 감지 (`pynput`)**:
    * 시스템 전역에서 마우스의 움직임과 클릭을 감지합니다 (백그라운드에서 작동).
    * 오른쪽 버튼이 눌리면(`is_right_button_pressed`) 좌표 기록을 시작합니다.

* **제스처 시각화 (`tkinter`)**:
    * 배경이 투명한 전체 화면 창(`GestureVisualizer`)을 만들어 화면 위에 띄웁니다.
    * 마우스 궤적에 따라 `Canvas`에 녹색 선을 그립니다.
    * **스레드 안전성 처리:** 마우스 리스너는 별도 스레드에서 돌지만, GUI 업데이트는 메인 스레드에서 처리해야 하므로 `root.after()`를 사용하여 충돌을 방지했습니다.

* **윈도우 제어 (`pygetwindow`, `pyautogui`)**:
    * `pygetwindow`: 현재 활성화된 창(`getActiveWindow`)을 감지하여 최소화, 최대화, 닫기 명령을 내립니다.
    * `pyautogui`: 키보드 단축키(Ctrl+C, Alt+F4 등)를 시뮬레이션하여 명령을 수행합니다.

* **제스처 판별 로직**:
    * 시작점과 끝점의 좌표 차이(`dx`, `dy`)를 계산합니다.
    * 설정된 임계값(`threshold`) 이상 움직였는지 확인하여 단순 떨림과 의도적인 제스처를 구분합니다.

### 요약
이 프로그램은 **"마우스 오른쪽 버튼을 누르고 긋는 동작"**만으로 복사/붙여넣기, 창 닫기, 웹서핑 뒤로 가기 등을 빠르게 수행할 수 있게 해주는 **생산성 도구**입니다.